//Задание 5. Т.к. cтатические свойства принадлежат классу, а не его экземплярам, при вызове функции из экземпляра класса свойство изменяется внутри класса
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

$a1 = new A(); //создаем первый экземпляр класса A
$a2 = new A(); //создаем второй экземпляр класса A
$a1->foo(); //обращаемся к функции foo() класса A, получаем значение 1
$a2->foo(); //обращаемся к функции foo() класса A, получаем значение 2
$a1->foo(); //обращаемся к функции foo() класса A, получаем значение 3
$a2->foo(); //обращаемся к функции foo() класса A, получаем значение 4


//Задание 6. В данном примере, в отличие от предыдущего, создаются 2 класса, каждому из которых принадлежит свое статическое свойство.
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

class B extends A { //создаем класс В - наследник класса A
}

$a1 = new A(); //создаем экземпляр класса A
$b1 = new B(); //создаем экземпляр класса В
$a1->foo(); //обращаемся к функции foo() класса A, получаем значение 1 
$b1->foo(); //обращаемся к функции foo() класса B, получаем значение 1 
$a1->foo(); //обращаемся к функции foo() класса A, получаем значение 2
$b1->foo(); //обращаемся к функции foo() класса B, получаем значение 2


//Задание 7. В данном задание, в отличие от предыдущего, при создании экземпляра класса нет круглых скобок. Тем не менее, пример работает также как предущий. Это объясняется тем, что скобки можно не ставить, если в конструктор ничего не передается.
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

class B extends A {
}

$a1 = new A; //нет скобок ()
$b1 = new B; //нет скобок ()
$a1->foo(); //1
$b1->foo(); //1
$a1->foo(); //2
$b1->foo(); //2